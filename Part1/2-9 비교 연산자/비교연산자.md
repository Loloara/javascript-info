### 비교 연산자

  * 큼 작음 > , < 
  * 크거나 작거나 같다 >= , <=
  * 같음(동등) ==  ( = ) 은 할당을 의미한다 (주소를 할당한다?)
  * 같지 않음(부등) != 

### 불린형 반환
  
  * 반환된 불린값은 다른 값처럼 변수에 할당 가능
  * let result = 5 > 4 // true
  * alert(result) // true

### 문자열 비교

  * 문자열은 사전편집(유니코드) 순으로 비교한다.
  * alert('Z' > 'A') // true
  * alert('Glow' > 'Glee') // true
  * 두만자열의 첫 글자 비교
  * 첫 번째 문자열의 첫 글자가 다른 문자열의 첫 글자보다 크거나 작으면 첫 번째 문자열이 두 번째 문자열보다 크거나 작다고 결론
  * 두 문자열의 첫 글자가 같으면 두 번째 글자를 같은 방식으로 비교

### 다른 형을 가진 값 간의 비교

  * 비교하려는 값의 자료형이 다르면 숫자형으로 변환 후 비교가 이루어짐
  * ==와 ===은 다르다 ==은 숫자형 0과 문자형 "0"을 비교했을때 true를 반환 ===은 false를 반환한다. ===은 형태까지 비교

### 일치 연산자
  
  * 동등 연산자 ==은 0과 false를 구별하지 못한다.
  * 빈 문자열일 떄도 같은 문제 발생 "" == false // true 
  * 동등연산자는 다른 피연산자를 비교할 때 피연산자를 숫자형으로 바꾸기 때문에 발생한다. 
  * ===의 부정 버전 !==

### null이나 undefined 비교하기
  
  * ===을 사용해 비교시 false 
  * ==으로 비교시 true

### null vs 0

  * null > 0 // false
  * null == 0 // false
  * null >== 0 // true
  * 이런 결과가 나타나는 이유는 동등 연산자( == ) 와 기타 비교 연산자 (<, >, >=) 의 동작 방식이 다르기 때문
  * 기타 연산자는 숫자형으로 변환 null이 0이됨 
  * 동등 연산자는 피연산자가 undefined 나 null일 때 변환을 하지 않는다. null이나 undefined를 다른 값과 비교할때 는 false

<hr/>

### 과제

  * 아래 표현식들의 결과를 예측해 보세요.
    1. 5 > 4
    2. "apple" > "pineapple"
    3. "2" > "12"
    4. undefined == null
    5. undefined === null
    6. null == "\n0\n"
    7. null === +"\n0\n"
    
    1. true
    2. false
    3. false (문자열이므로 사전순으로 비교가 이루어진다 사전순 첫 번째 글자 비교시 2가 1보다 크기 때문에 true)
    4. true
    5. false
    6. true (null은 오직 undefined와 같다. false)
    7. false
